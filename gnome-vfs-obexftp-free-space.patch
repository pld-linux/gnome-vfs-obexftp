# Bazaar revision bundle v0.9
#
# message:
#   In the OBEX capabilities parser, record whether we've actually seen the 
#   <Used> and <Free> values for each memory type, and store that in the 
#   resulting OvuCapsMemory objext.
#   
#   Update the tests to handle the new API and fix the output samples to 
#   match the now correct data.
#   
#   This should fix bug #120214 (Faulty reporting of free space with Sony 
#   Ericsson z710).
#   
# committer: James Henstridge <james@jamesh.id.au>
# date: Fri 2007-06-15 14:30:15.776999950 +0800

=== modified file src/obex-method.c
--- src/obex-method.c
+++ src/obex-method.c
@@ -1738,7 +1738,7 @@
 	caps = ovu_caps_parser_parse (caps_str, len, &gerror);
 
 	memory = ovu_caps_get_memory_type (caps, mem_type);
-	if (memory != NULL) {
+	if (memory != NULL && ovu_caps_memory_has_free (memory)) {
 		*free_space = ovu_caps_memory_get_free (memory);
 	} else {
 		result = GNOME_VFS_ERROR_NOT_SUPPORTED;

=== modified file src/ovu-cap-parser.c
--- src/ovu-cap-parser.c
+++ src/ovu-cap-parser.c
@@ -59,7 +59,7 @@
 
 	PARSER_STATE_INBOX,
 	PARSER_STATE_SERVICE,
-	
+
 	PARSER_STATE_SKIP
 } ParserState;
 
@@ -72,12 +72,14 @@
 	gchar             *memory_type;
 	GnomeVFSFileSize   memory_free;
 	GnomeVFSFileSize   memory_used;
+	gboolean           memory_has_free;
+	gboolean           memory_has_used;
 	gboolean           memory_case_sensitive;
 
 	GError           **error;
 } ParserData;
 
-static void    cap_parser_start_node_cb   (void                 *user_data, 
+static void    cap_parser_start_node_cb   (void                 *user_data,
 					   const char           *node_name,
 					   const char          **attr);
 
@@ -95,22 +97,22 @@
 {
 	data->state = g_list_prepend (data->state,
 				      GINT_TO_POINTER (state));
-}      
+}
 
 static ParserState
 cap_parser_pop_state (ParserData *data)
 {
 	ParserState state;
-	
+
 	if (!data->state) {
 		return PARSER_STATE_INVALID;
 	}
-	
+
 	state = GPOINTER_TO_INT (data->state->data);
 	data->state = g_list_delete_link (data->state, data->state);
 
 	return state;
-}      
+}
 
 static ParserState
 cap_parser_peek_state (ParserData *data)
@@ -118,7 +120,7 @@
 	if (!data->state) {
 		return PARSER_STATE_START;
 	}
-	
+
 	return GPOINTER_TO_INT (data->state->data);
 }
 
@@ -126,30 +128,30 @@
 cap_parser_get_attribute_value (const char  *name, const char **attr)
 {
 	gint i = 0;
-  
+
 	while (attr[i]) {
 		if (strcmp (name, attr[i]) == 0) {
 			return attr[i + 1];
 		}
 		i += 2;
 	}
-	
+
 	return "";
 }
 
 static void
-cap_parser_start_node_cb (void        *user_data, 
+cap_parser_start_node_cb (void        *user_data,
 			  const char  *node_name,
 			  const char **attr)
 {
 	ParserData  *data;
 	ParserState  state;
 	const gchar *version;
-	
+
 	data = (ParserData *) user_data;
-	
+
 	state = cap_parser_peek_state (data);
-	
+
 	switch (state) {
 	case PARSER_STATE_START:
 		if (strcmp (node_name, "Capability") != 0) {
@@ -188,7 +190,7 @@
 			return;
 		}
 		break;
-		
+
 	case PARSER_STATE_GENERAL:
 		if (strcmp (node_name, "Memory") == 0) {
 			cap_parser_push_state (data, PARSER_STATE_MEMORY);
@@ -213,7 +215,7 @@
 				     node_name);
 			return;
 		}
-		
+
 		break;
 
 	case PARSER_STATE_MEMORY:
@@ -259,13 +261,13 @@
 			return;
 		}
 		break;
-		
+
 	case PARSER_STATE_INBOX:
 	case PARSER_STATE_SERVICE:
 		/* Skip these for now. */
 		cap_parser_push_state (data, PARSER_STATE_SKIP);
 		break;
-		
+
 	case PARSER_STATE_SKIP:
 		cap_parser_push_state (data, PARSER_STATE_SKIP);
 		break;
@@ -284,6 +286,8 @@
 	data->memory_type = NULL;
 	data->memory_free = 0;
 	data->memory_used = 0;
+	data->memory_has_free = FALSE;
+	data->memory_has_used = FALSE;
 	data->memory_case_sensitive = FALSE;
 }
 
@@ -301,14 +305,16 @@
 	switch (state) {
 	case PARSER_STATE_INVALID:
 		return;
-		
+
 	case PARSER_STATE_MEMORY:
 		memory = ovu_caps_memory_new (data->memory_type,
 					      data->memory_free,
 					      data->memory_used,
+					      data->memory_has_free,
+					      data->memory_has_used,
 					      data->memory_case_sensitive);
-		
-		data->memory_entries = g_list_prepend (data->memory_entries, 
+
+		data->memory_entries = g_list_prepend (data->memory_entries,
 						       memory);
 		cap_parser_reset_memory (data);
 		break;
@@ -323,21 +329,25 @@
 }
 
 /* Parse a long, return -1 if input is not strictly valid or null. */
-static glong
-parse_long (const gchar *str)
+static GnomeVFSFileSize
+parse_long (const gchar *str, gboolean *success)
 {
 	gchar *endptr;
 	glong  l;
 
+	*success = TRUE;
+
 	if (!str) {
-		return -1;
+		*success = FALSE;
+		return 0;
 	}
-	
+
 	l = strtol (str, &endptr, 10);
-	if (endptr[0] != '\0') {
-		l = -1;
-	}			
-	
+	if (endptr[0] != '\0' || l < 0) {
+		*success = FALSE;
+		l = 0;
+	}
+
 	return l;
 }
 
@@ -362,10 +372,10 @@
 		data->memory_type = g_strdup (tmp);
 		break;
 	case PARSER_STATE_MEMORY_FREE:
-		data->memory_free = parse_long (tmp);
+		data->memory_free = parse_long (tmp, &data->memory_has_free);
 		break;
 	case PARSER_STATE_MEMORY_USED:
-		data->memory_used = parse_long (tmp);
+		data->memory_used = parse_long (tmp, &data->memory_has_used);
 		break;
 
 	default:
@@ -385,7 +395,7 @@
 	XML_SetElementHandler (parser,
 			       cap_parser_start_node_cb,
 			       cap_parser_end_node_cb);
-	
+
 	XML_SetCharacterDataHandler (parser, cap_parser_text_cb);
 
 	XML_SetUserData (parser, data);
@@ -397,12 +407,12 @@
 cap_parser_free (ParserData *data, gboolean free_data)
 {
 	cap_parser_reset_memory (data);
-	
+
 	if (free_data) {
 		g_list_foreach (data->memory_entries,
 				(GFunc) ovu_caps_memory_free, NULL);
 	}
-	
+
 	g_free (data);
 }
 

=== modified file src/ovu-caps.c
--- src/ovu-caps.c
+++ src/ovu-caps.c
@@ -37,9 +37,11 @@
 
 struct _OvuCapsMemory {
         gchar            *type;
+        GnomeVFSFileSize  free;
         GnomeVFSFileSize  used;
-        GnomeVFSFileSize  free;
-        gboolean          case_sensitive;
+        guint             has_free : 1;
+	guint             has_used : 1;
+        guint             case_sensitive : 1;
 };
 
 
@@ -47,15 +49,19 @@
 ovu_caps_memory_new (const gchar      *type,
 		     GnomeVFSFileSize  free,
 		     GnomeVFSFileSize  used,
+		     gboolean          has_free,
+		     gboolean          has_used,
 		     gboolean          case_sensitive)
 {
 	OvuCapsMemory *memory;
-	
+
 	memory = g_new0 (OvuCapsMemory, 1);
 
 	memory->type = g_strdup (type);
 	memory->free = free;
 	memory->used = used;
+	memory->has_free = has_free;
+	memory->has_used = has_used;
 	memory->case_sensitive = case_sensitive;
 
 	return memory;
@@ -104,7 +110,7 @@
 {
 	g_list_foreach (caps->memory_entries,
 			(GFunc) ovu_caps_memory_free, NULL);
-	
+
 	g_list_free (caps->memory_entries);
 
 	g_free (caps);
@@ -156,6 +162,18 @@
 }
 
 gboolean
+ovu_caps_memory_has_used (OvuCapsMemory *memory)
+{
+	return memory->has_used;
+}
+
+gboolean
+ovu_caps_memory_has_free (OvuCapsMemory *memory)
+{
+	return memory->has_free;
+}
+
+gboolean
 ovu_caps_memory_get_case_sensitive (OvuCapsMemory *memory)
 {
 	return memory->case_sensitive;

=== modified file src/ovu-caps.h
--- src/ovu-caps.h
+++ src/ovu-caps.h
@@ -27,21 +27,25 @@
 typedef struct _OvuCaps       OvuCaps;
 typedef struct _OvuCapsMemory OvuCapsMemory;
 
-GList *          ovu_caps_get_memory_entries        (OvuCaps           *caps);
-OvuCapsMemory   *ovu_caps_get_memory_type           (OvuCaps           *caps,
-						     const gchar       *mem_type);
-void             ovu_caps_free                      (OvuCaps           *caps);
-OvuCapsMemory *  ovu_caps_memory_new                (const gchar       *type,
-						     GnomeVFSFileSize   free,
-						     GnomeVFSFileSize   used,
-						     gboolean           case_sensitive);
-void             ovu_caps_memory_free               (OvuCapsMemory     *memory);
-gboolean         ovu_caps_memory_equal              (OvuCapsMemory     *m1,
-						     OvuCapsMemory     *m2);
-const gchar *    ovu_caps_memory_get_type           (OvuCapsMemory     *memory);
-GnomeVFSFileSize ovu_caps_memory_get_used           (OvuCapsMemory     *memory);
-GnomeVFSFileSize ovu_caps_memory_get_free           (OvuCapsMemory     *memory);
-gboolean         ovu_caps_memory_get_case_sensitive (OvuCapsMemory     *memory);
+GList *          ovu_caps_get_memory_entries        (OvuCaps         *caps);
+OvuCapsMemory   *ovu_caps_get_memory_type           (OvuCaps         *caps,
+						     const gchar     *mem_type);
+void             ovu_caps_free                      (OvuCaps         *caps);
+OvuCapsMemory *  ovu_caps_memory_new                (const gchar     *type,
+						     GnomeVFSFileSize free,
+						     GnomeVFSFileSize used,
+						     gboolean         has_free,
+						     gboolean         has_used,
+						     gboolean         case_sensitive);
+void             ovu_caps_memory_free               (OvuCapsMemory   *memory);
+gboolean         ovu_caps_memory_equal              (OvuCapsMemory   *m1,
+						     OvuCapsMemory   *m2);
+const gchar *    ovu_caps_memory_get_type           (OvuCapsMemory   *memory);
+GnomeVFSFileSize ovu_caps_memory_get_used           (OvuCapsMemory   *memory);
+GnomeVFSFileSize ovu_caps_memory_get_free           (OvuCapsMemory   *memory);
+gboolean         ovu_caps_memory_has_used           (OvuCapsMemory   *memory);
+gboolean         ovu_caps_memory_has_free           (OvuCapsMemory   *memory);
+gboolean         ovu_caps_memory_get_case_sensitive (OvuCapsMemory   *memory);
 
 
 #endif /* __OVU_CAPS_H__ */
